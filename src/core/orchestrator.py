"""Message Orchestrator - routes messages between pipeline and agent mode.

The orchestrator is the main entry point for message processing:
1. Checks for active session → routes to AgentHandler
2. Runs Pipeline → handles triggers or signals state collection needed
3. Creates session if state collection is needed
"""

from __future__ import annotations

import logging
from datetime import UTC, datetime, timedelta
from typing import TYPE_CHECKING
from uuid import uuid4

from src.core.dedupe import DedupeManager
from src.core.models import (
    HandlerResult,
    NormalizedEvent,
    OutboundMessage,
    PipelineResult,
    Session,
    SessionGoal,
    SessionStatus,
)
from src.core.prompts import get_ui_message
from src.core.rate_limiter import get_rate_limit_manager
from src.core.timezone_identity import generate_verify_token, get_verify_url
from src.settings import get_settings

if TYPE_CHECKING:
    from src.core.agent_handler import AgentHandler
    from src.core.pipeline import Pipeline
    from src.storage.mongo import MongoStorage

logger = logging.getLogger(__name__)


class MessageOrchestrator:
    """Routes messages between pipeline and agent mode.

    Single decision point for all trigger handling. Flow:
    1. Check for active session → AgentHandler
    2. Dedupe/throttle/rate limit checks
    3. Pipeline processing (detection + context + action handlers)
    4. Orchestrator decides what to do with each trigger:
       - mention → send help message
       - relocation → reset confidence + create session
       - time without TZ → create onboarding session
       - time with TZ → messages already generated by Pipeline
    """

    def __init__(
        self,
        storage: MongoStorage,
        pipeline: Pipeline,
        agent_handler: AgentHandler,
        base_url: str = "",
    ) -> None:
        """Initialize the orchestrator.

        Args:
            storage: MongoDB storage instance.
            pipeline: Main message processing pipeline.
            agent_handler: Agent handler for session-based conversations.
            base_url: Base URL for verification links.
        """
        self.storage = storage
        self.pipeline = pipeline
        self.agent_handler = agent_handler
        self.base_url = base_url
        self.dedupe = DedupeManager(storage)
        self._settings = get_settings()

    async def route(self, event: NormalizedEvent) -> HandlerResult:
        """Route an incoming message to the appropriate handler.

        Args:
            event: Normalized incoming message event.

        Returns:
            HandlerResult from the appropriate handler.
        """
        # 1. Check for active session
        session = await self.storage.get_active_session(
            event.platform, event.chat_id, event.user_id
        )

        if session:
            logger.debug(
                f"Active session found for user {event.user_id}, "
                f"routing to agent handler (goal: {session.goal})"
            )
            return await self.agent_handler.handle(session, event)

        # 2. Dedupe check
        if await self.dedupe.is_duplicate(event.platform, event.event_id):
            logger.debug(f"Duplicate event: {event.event_id}")
            return HandlerResult(should_respond=False)

        # 3. Throttle check
        if self.dedupe.is_throttled(event.platform, event.chat_id):
            logger.debug(f"Throttled chat: {event.chat_id}")
            return HandlerResult(should_respond=False)

        # 4. Rate limit check
        rate_limiter = get_rate_limit_manager()
        is_allowed, limit_type = rate_limiter.check_rate_limit(
            event.platform.value, event.user_id, event.chat_id
        )
        if not is_allowed:
            logger.info(f"Rate limited ({limit_type}): user={event.user_id} chat={event.chat_id}")

            # Notify user about rate limit (first N times, then stay silent)
            if rate_limiter.should_notify_rate_limit(event.platform.value, event.user_id):
                retry_after = (
                    rate_limiter.get_user_retry_after(event.platform.value, event.user_id)
                    if limit_type == "user"
                    else rate_limiter.get_chat_retry_after(event.platform.value, event.chat_id)
                )
                message = OutboundMessage(
                    platform=event.platform,
                    chat_id=event.chat_id,
                    text=f"⏳ Rate limit reached. Please wait {retry_after} seconds.",
                    parse_mode="plain",
                )
                return HandlerResult(should_respond=True, messages=[message])

            return HandlerResult(should_respond=False)

        # 5. Process through pipeline (detection + context + action handlers)
        logger.debug(f"Processing event through pipeline for user {event.user_id}")
        result = await self.pipeline.process(event)

        # 6. Decide what to do with triggers
        # Priority: mention > relocation > time
        for trigger in result.triggers:
            action = self._decide_action(trigger, result)

            if action == "send_help":
                logger.info(f"Help request from user {event.user_id}")
                return await self._send_help_message(event)

            elif action == "create_relocation_session":
                logger.info(f"Relocation detected for user {event.user_id}")
                # Reset confidence via relocation handler
                await self._reset_user_confidence(event)
                return await self._handle_relocation(event, trigger)

            elif action == "create_timezone_session":
                logger.info(f"Timezone session needed for user {event.user_id}")
                return await self._create_timezone_session(event, trigger)

            elif action == "classify_geo_intent":
                logger.info(
                    f"Geo ambiguous trigger for user {event.user_id}, creating agent session"
                )
                return await self._handle_geo_ambiguous(event, trigger, result.triggers)

        # 7. If we have messages from handlers, return them
        if result.messages:
            await self.dedupe.mark_processed(event.platform, event.event_id, event.chat_id)
            self.dedupe.record_response(event.platform, event.chat_id)

        return HandlerResult(
            should_respond=bool(result.messages),
            messages=result.messages,
        )

    def _decide_action(self, trigger, result: PipelineResult) -> str | None:
        """Decide what action to take for a trigger.

        Single decision point for all trigger types.

        Routing table:
        | Triggers         | User TZ | TZ hint | Action                    |
        |------------------|---------|---------|---------------------------|
        | time only        | ✓ known | -       | Convert from user_tz      |
        | time only        | ✗ unknown| -      | → Agent (AWAITING_TZ)     |
        | time + TZ hint   | any     | ✓       | Convert from TZ hint      |
        | time + geo       | any     | -       | → Agent (CLARIFY_GEO)     |
        | geo only         | any     | -       | → Agent (CLARIFY_GEO)     |
        | relocation regex | any     | -       | → CONFIRM_RELOCATION      |

        Args:
            trigger: The detected trigger.
            result: Pipeline result with context.

        Returns:
            Action string or None if no action needed.
        """
        # Mention triggers → send help message
        if trigger.trigger_type == "mention":
            return "send_help"

        # Relocation triggers (regex patterns) → reset confidence + create session
        if trigger.trigger_type == "relocation":
            return "create_relocation_session"

        # Geo ambiguous (city detected via geonames, intent unclear)
        if trigger.trigger_type == "geo_ambiguous":
            # Check if time trigger has explicit TZ hint → time query, no agent needed
            time_triggers = [t for t in result.triggers if t.trigger_type == "time"]
            if time_triggers:
                time_has_explicit_tz = time_triggers[0].data.get("is_explicit_tz", False)
                if time_has_explicit_tz:
                    # Time trigger already resolved TZ from message → Pipeline converted
                    logger.debug(
                        "Geo trigger + time with explicit TZ - Pipeline handles conversion"
                    )
                    return None
            # No explicit TZ in time, or no time trigger → agent decides intent
            return "classify_geo_intent"

        # Time triggers
        if trigger.trigger_type == "time":
            is_explicit_tz = trigger.data.get("is_explicit_tz", False)

            # If time has explicit TZ hint (e.g., "в 15 по Москве") → Pipeline converts
            if is_explicit_tz and result.messages:
                return None

            # Check if geo_ambiguous also present without explicit TZ
            has_geo_trigger = any(t.trigger_type == "geo_ambiguous" for t in result.triggers)
            if has_geo_trigger and not is_explicit_tz:
                # Time without TZ + geo → agent decides if geo is TZ hint or relocation
                logger.debug("Time (no TZ) + geo triggers - agent will clarify via geo_ambiguous")
                return None

            # Time only - check if conversion succeeded (messages generated)
            if result.messages:
                # Success: had user TZ
                return None

            # No messages = missing timezone → onboarding session
            return "create_timezone_session"

        return None

    async def _send_help_message(self, event: NormalizedEvent) -> HandlerResult:
        """Send help message for mention triggers."""
        text = get_ui_message("help")
        message = OutboundMessage(
            platform=event.platform,
            chat_id=event.chat_id,
            text=text,
            parse_mode="plain",
        )
        await self.dedupe.mark_processed(event.platform, event.event_id, event.chat_id)
        self.dedupe.record_response(event.platform, event.chat_id)
        return HandlerResult(should_respond=True, messages=[message])

    async def _reset_user_confidence(self, event: NormalizedEvent) -> None:
        """Reset user's timezone confidence for relocation."""
        config = self._settings.config.confidence
        user_state = await self.storage.get_user_tz_state(event.platform, event.user_id)
        if user_state:
            user_state.confidence = config.relocation_reset
            await self.storage.upsert_user_tz_state(user_state)

    async def _handle_relocation(self, event: NormalizedEvent, trigger) -> HandlerResult:
        """Handle relocation trigger - try geocoding or create session."""
        city = trigger.data.get("city", "")
        if city:
            geocode_result = self._try_geocode_city(city)
            if geocode_result:
                resolved_city, resolved_tz = geocode_result
                return await self._create_confirm_relocation_session(
                    event, resolved_city, resolved_tz, trigger.data
                )

        # Can't geocode - create reverify session
        return await self._create_timezone_session(event, trigger, is_relocation=True)

    async def _create_timezone_session(
        self, event: NormalizedEvent, trigger, is_relocation: bool = False
    ) -> HandlerResult:
        """Create timezone collection session (onboarding or reverify)."""
        # Generate verification token
        token = generate_verify_token(event.platform, event.user_id, event.chat_id)
        verify_url = get_verify_url(token, self.base_url)

        # Check if this is re-verification or first-time onboarding
        user_state = await self.storage.get_user_tz_state(event.platform, event.user_id)
        is_reverify = is_relocation or (user_state is not None and user_state.tz_iana is not None)

        # Choose goal and prompt based on scenario
        existing_tz: str | None = None
        if is_reverify and user_state is not None and user_state.tz_iana is not None:
            goal = SessionGoal.REVERIFY_TIMEZONE
            existing_tz = user_state.tz_iana
            text = get_ui_message("reverify", existing_tz=existing_tz)
        else:
            goal = SessionGoal.AWAITING_TIMEZONE
            text = get_ui_message("onboarding")

        # Create session
        session = Session(
            session_id=str(uuid4()),
            platform=event.platform,
            chat_id=event.chat_id,
            user_id=event.user_id,
            goal=goal,
            status=SessionStatus.ACTIVE,
            context={
                "original_text": event.text,
                "trigger_data": trigger.data if trigger else {},
                "verify_url": verify_url,
                "attempts": 0,
                "history": [],
                "existing_tz": existing_tz,
            },
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
            expires_at=datetime.now(UTC) + timedelta(minutes=30),
        )
        await self.storage.create_session(session)
        logger.info(
            f"Created {'re-verify' if is_reverify else 'onboarding'} "
            f"session {session.session_id} for user {event.user_id}"
        )

        message = OutboundMessage(
            platform=event.platform,
            chat_id=event.chat_id,
            text=text,
            parse_mode="plain",
        )
        await self.dedupe.mark_processed(event.platform, event.event_id, event.chat_id)
        self.dedupe.record_response(event.platform, event.chat_id)

        return HandlerResult(
            should_respond=True,
            messages=[message],
            ask_timezone=True,
            verify_url=verify_url,
        )

    def _try_geocode_city(self, city: str) -> tuple[str, str] | None:
        """Try to geocode a city name using geonamescache + LLM normalization.

        Handles Cyrillic names (Сочи → Sochi), abbreviations (MSK → Moscow),
        and other non-English inputs via LLM normalization.

        Args:
            city: City name to geocode (any language).

        Returns:
            Tuple of (city_name, tz_iana) if found, None otherwise.
        """
        from src.core.geo import geocode_city

        result = geocode_city(city, use_llm=True)
        if result:
            resolved_city, resolved_tz = result
            logger.info(f"Geocode success: '{city}' → {resolved_city} ({resolved_tz})")
            return result
        return None

    async def _create_confirm_relocation_session(
        self,
        event: NormalizedEvent,
        resolved_city: str,
        resolved_tz: str,
        trigger_data: dict,
    ) -> HandlerResult:
        """Create a simple confirmation session for relocation.

        This is a lightweight session that doesn't need LLM agent.
        User just confirms "yes" or provides different city.

        Args:
            event: The event being processed.
            resolved_city: Geocoded city name.
            resolved_tz: Resolved IANA timezone.
            trigger_data: Original trigger data.

        Returns:
            HandlerResult with confirmation prompt.
        """
        session = Session(
            session_id=str(uuid4()),
            platform=event.platform,
            chat_id=event.chat_id,
            user_id=event.user_id,
            goal=SessionGoal.CONFIRM_RELOCATION,
            status=SessionStatus.ACTIVE,
            context={
                "original_text": event.text,
                "trigger_data": trigger_data,
                "resolved_city": resolved_city,
                "resolved_tz": resolved_tz,
                "attempts": 0,
            },
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
            expires_at=datetime.now(UTC) + timedelta(minutes=30),
        )
        await self.storage.create_session(session)
        logger.info(
            f"Created confirm_relocation session {session.session_id} for user {event.user_id}: "
            f"{resolved_city} → {resolved_tz}"
        )

        # Send confirmation message
        text = get_ui_message("confirm_relocation", city_name=resolved_city, tz_iana=resolved_tz)
        message = OutboundMessage(
            platform=event.platform,
            chat_id=event.chat_id,
            text=text,
            parse_mode="html",
        )

        self.dedupe.record_response(event.platform, event.chat_id)

        return HandlerResult(
            should_respond=True,
            messages=[message],
            ask_timezone=True,
        )

    async def _handle_geo_ambiguous(
        self, event: NormalizedEvent, trigger, all_triggers: list
    ) -> HandlerResult:
        """Handle ambiguous geo detection by creating an agent session.

        Instead of simple LLM classification, create a session with a smart agent
        that has full context (all triggers, user timezone, etc.) and can:
        - Convert time if it's a time query
        - Save timezone if it's relocation
        - Ask user if unclear
        - Skip if false positive

        Args:
            event: The event being processed.
            trigger: The geo_ambiguous trigger with city data.
            all_triggers: All detected triggers for context.

        Returns:
            HandlerResult from agent session creation.
        """
        city = trigger.data.get("city", "")
        timezone = trigger.data.get("timezone", "")

        # Collect context for the agent
        time_triggers = [t for t in all_triggers if t.trigger_type == "time"]
        time_detected = None
        if time_triggers:
            time_detected = time_triggers[0].original_text

        # Get user's current timezone if available
        user_state = await self.storage.get_user_tz_state(event.platform, event.user_id)
        user_tz = user_state.tz_iana if user_state else None

        # Create session with full context for the agent
        session = Session(
            session_id=str(uuid4()),
            platform=event.platform,
            chat_id=event.chat_id,
            user_id=event.user_id,
            goal=SessionGoal.CLARIFY_GEO_INTENT,
            status=SessionStatus.ACTIVE,
            context={
                "original_text": event.text,
                "city": city,
                "timezone": timezone,
                "time_detected": time_detected,
                "user_tz": user_tz,
                "trigger_data": trigger.data,
                "all_triggers": [
                    {"type": t.trigger_type, "text": t.original_text, "data": t.data}
                    for t in all_triggers
                ],
                "attempts": 0,
                "history": [],
            },
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
            expires_at=datetime.now(UTC) + timedelta(minutes=10),
        )
        await self.storage.create_session(session)
        logger.info(
            f"Created CLARIFY_GEO_INTENT session {session.session_id} for user {event.user_id}: "
            f"city={city}, time_detected={time_detected}"
        )

        # Let the agent handler process immediately with the initial message
        return await self.agent_handler.handle(session, event)
